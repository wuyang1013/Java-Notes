# 多线程

## **Java线程的创建方式**

共有四种方式可以创建线程，分别是：继承Thread类、实现runnable接口、实现Callable接口、线程池创建线程

* **继承 `Thread` 类**

  ```java

      @Override
      public void run() {
          System.out.println("MyThread...run...");
      }

      public static void main(String[] args) {

          // 创建MyThread对象
          MyThread t1 = new MyThread() ;
          MyThread t2 = new MyThread() ;

          // 调用start方法启动线程
          t1.start();
          t2.start();

      }

  }
  ```
* **实现 `Runnable` 接口 (推荐)**

  ```java
  public class MyRunnable implements Runnable{

      @Override
      public void run() {
          System.out.println("MyRunnable...run...");
      }

      public static void main(String[] args) {

          // 创建MyRunnable对象
          MyRunnable mr = new MyRunnable() ;

          // 创建Thread对象
          Thread t1 = new Thread(mr) ;
          Thread t2 = new Thread(mr) ;

          // 调用start方法启动线程
          t1.start();
          t2.start();

      }

  }


  ```

  *优点：避免了单继承的局限性，更适合资源共享。*
* *实现 `Callable` 接口 + `FutureTask` (可以获取返回值)*

  ```java
  public class MyCallable implements Callable<String> {

      @Override
      public Integer call() throws Exception {
          // 执行任务并返回结果
  	System.out.println("MyCallable...call...");
          return “success”;
      }

      public static void main(String[] args) throws ExecutionException, InterruptedException {

          // 创建MyCallable对象
          MyCallable mc = new MyCallable() ;

          // 创建F
          FutureTask<String> ft = new FutureTask<String>(mc) ;

          // 创建Thread对象
          Thread t1 = new Thread(ft) ;
          Thread t2 = new Thread(ft) ;

          // 调用start方法启动线程
          t1.start();

          // 调用ft的get方法获取执行结果
          String result = ft.get();

          // 输出
          System.out.println(result);

      }

  }
  ```
* **使用线程池 (`ExecutorService`)**

```Java
public class MyExecutors implements Runnable{

    @Override
    public void run() {
        System.out.println("MyRunnable...run...");
    }

    public static void main(String[] args) {

        // 创建线程池对象
        ExecutorService threadPool = Executors.newFixedThreadPool(3);
        threadPool.submit(new MyExecutors()) ;

        // 关闭线程池
        threadPool.shutdown();

    }

}
```

## 线程池

#### 参数

1. corePoolSize 核心线程数目 - 池中会保留的最多线程数
2. maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目
3. keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放
4. unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等
5. workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务
6. threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等
7. handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略

## ThreadLocal

ThreadLocal是多线程中对于解决线程安全的一个操作类，它会为每个线程都分配一个独立的线程副本从而解决了变量并发访问冲突的问题。ThreadLocal 同时实现了线程内的资源共享

案例：使用JDBC操作数据库时，会将每一个线程的Connection放入各自的ThreadLocal中，从而保证每个线程都在各自的 Connection 上进行数据库的操作，避免A线程关闭了B线程的连接。

三个主要方法：

- set(value) 设置值
- get() 获取值
- remove() 清除值

#### ThreadLocal-内存泄露问题

Java对象中的四种引用类型：强引用、软引用、弱引用、虚引用

- 强引用：最为普通的引用方式，表示一个对象处于有用且必须的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收

![img](assets/1757580312904-3.png)

- 弱引用：表示一个对象处于可能有用且非必须的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收

![img](assets/1757580312904-1.png)

每一个Thread维护一个ThreadLocalMap，在ThreadLocalMap中的Entry对象继承了WeakReference。其中key为使用弱引用的ThreadLocal实例，value为线程变量的副本

![img](assets/1757580312904-2.png)

在使用ThreadLocal的时候，强烈建议：**务必手动remove**
