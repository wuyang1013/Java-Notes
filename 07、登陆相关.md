# 登陆相关

## cookie,session和token

### 总结

* **Cookie** ：是一种由服务器发送到浏览器并由浏览器保存、然后在后续请求中自动带回的一小段数据（HTTP Header）。
* **Session** ：是指服务器端为维护特定用户会话状态而创建和存储的数据结构。它通常需要依赖Cookie（或URL重写）来与客户端关联。
* **Token** （通常指JWT）：是一个 **凭证** ，一种自包含的、含有用户信息和签名校验的字符串。它由服务器签发，由客户端存储，并在请求时带给服务器用于验证。

### 联系与区别

| 特性               | Cookie                                    | Session                                             | Token (e.g., JWT)                                          |
| ------------------ | ----------------------------------------- | --------------------------------------------------- | ---------------------------------------------------------- |
| **存储位置** | **客户端**浏览器                    | **服务器端** （内存、数据库、Redis）          | **客户端** （由开发者决定存localStorage或Cookie）    |
| **本质**     | **数据传递的机制/载体**             | **服务器上的数据对象**                        | **自包含的验证凭证**                                 |
| **安全性**   | 较低，易被CSRF和XSS攻击（可通过属性提升） | 较高，数据在服务器端                                | 较高，防篡改（有签名），但需防范XSS（若存localStorage）    |
| **扩展性**   | \                                         | 差，服务器集群间同步Session状态复杂                 | **好，无状态** ，天然支持分布式部署                  |
| **性能影响** | \                                         | 服务器需要频繁查询存储以获取Session数据             | 服务器只需验证签名，无需存储查询（但无法在失效前强制注销） |
| **跨域支持** | 受限制（遵循同源策略）                    | 受限制（默认依赖Cookie）                            | 良好，可轻松用于跨域场景（CORS）                           |
| **工作方式** | **自动**由浏览器管理并携带          | 依赖客户端带回**Session ID** （通常用Cookie） | **手动**由开发者添加到请求头中                       |

### JWT

JSON Web Token（JWT）是一种开放标准（RFC 7519），用于在各方之间安全地传输信息作为JSON对象。在Java应用中，JWT常用于身份验证和信息交换。

#### JWT结构

JWT由三部分组成，用点号分隔：

* Header（头部）
* Payload（载荷）
* Signature（签名）

格式：`header.payload.signature`

#### 在Java中的应用

Maven依赖（版本一致，避免兼容性问题）：

```xml
<!-- JJWT API 模块：提供用于创建和解析 JWT 的核心 API 接口 -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.11.5</version>
</dependency>

<!-- JJWT 实现模块：包含 API 的具体实现，运行时依赖（编译时无需） -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>  <!-- 仅运行时生效，避免编译时耦合具体实现 -->
</dependency>

<!-- JJWT Jackson 序列化模块：提供基于 Jackson 的 JSON 序列化支持 -->
<!-- 注意：也可选择 jjwt-gson 模块（根据项目JSON库偏好二选一） -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>  <!-- 仅运行时生效，确保解析逻辑与具体序列化库解耦 -->
</dependency>
```

#### JWT的生成和解析（JWT工具类）

```java
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SecurityException;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

/**
 * JWT 工具类
 * 用于生成、解析和验证 JWT Token
 */
public class JwtUtil {
  
    // 默认的密钥，实际项目中应该从配置文件中读取，且需要保证安全性
    private static final String DEFAULT_SECRET = "mySecretKeymySecretKeymySecretKeymySecretKey";
  
    // 默认的Token有效期（毫秒），这里设置为2小时
    private static final long DEFAULT_EXPIRATION = 7200000;
  
    // 生成安全的密钥
    private static final SecretKey SECRET_KEY = Keys.hmacShaKeyFor(DEFAULT_SECRET.getBytes());
  
    /**
     * 生成JWT Token
     * @param claims 自定义声明
     * @return JWT Token字符串
     */
    public static String generateToken(Map<String, Object> claims) {
        return generateToken(claims, DEFAULT_EXPIRATION);
    }
  
    /**
     * 生成JWT Token
     * @param claims 自定义声明
     * @param expiration 有效期（毫秒）
     * @return JWT Token字符串
     */
    public static String generateToken(Map<String, Object> claims, long expiration) {
        return Jwts.builder()
                .setClaims(claims) // 自定义声明
                .setIssuedAt(new Date()) // 签发时间
                .setExpiration(new Date(System.currentTimeMillis() + expiration)) // 过期时间
                .signWith(SECRET_KEY, SignatureAlgorithm.HS256) // 签名算法和密钥
                .compact();
    }
  
    /**
     * 生成JWT Token（简单版）
     * @param subject 主题（通常是用户ID或用户名）
     * @return JWT Token字符串
     */
    public static String generateToken(String subject) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("sub", subject);
        return generateToken(claims);
    }
  
    /**
     * 从Token中解析声明
     * @param token JWT Token
     * @return 声明集合
     */
    public static Claims parseToken(String token) {
        try {
            return Jwts.parserBuilder()
                    .setSigningKey(SECRET_KEY)
                    .build()
                    .parseClaimsJws(token)
                    .getBody();
        } catch (ExpiredJwtException e) {
            throw new RuntimeException("Token已过期", e);
        } catch (SecurityException e) {
            throw new RuntimeException("Token签名无效", e);
        } catch (JwtException e) {
            throw new RuntimeException("Token解析失败", e);
        }
    }
  
    /**
     * 从Token中获取指定声明值
     * @param token JWT Token
     * @param claimName 声明名称
     * @return 声明值
     */
    public static Object getClaim(String token, String claimName) {
        Claims claims = parseToken(token);
        return claims.get(claimName);
    }
  
    /**
     * 从Token中获取主题（用户ID或用户名）
     * @param token JWT Token
     * @return 主题
     */
    public static String getSubject(String token) {
        Claims claims = parseToken(token);
        return claims.getSubject();
    }
  
    /**
     * 验证Token是否有效
     * @param token JWT Token
     * @return 是否有效
     */
    public static boolean validateToken(String token) {
        try {
            parseToken(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
  
    /**
     * 验证Token是否过期
     * @param token JWT Token
     * @return 是否过期
     */
    public static boolean isTokenExpired(String token) {
        try {
            Claims claims = parseToken(token);
            return claims.getExpiration().before(new Date());
        } catch (ExpiredJwtException e) {
            return true;
        } catch (Exception e) {
            throw new RuntimeException("Token验证失败", e);
        }
    }
  
    /**
     * 获取Token的过期时间
     * @param token JWT Token
     * @return 过期时间
     */
    public static Date getExpirationDate(String token) {
        Claims claims = parseToken(token);
        return claims.getExpiration();
    }
  
    /**
     * 获取Token的签发时间
     * @param token JWT Token
     * @return 签发时间
     */
    public static Date getIssuedAtDate(String token) {
        Claims claims = parseToken(token);
        return claims.getIssuedAt();
    }
  
    /**
     * 刷新Token（更新过期时间）
     * @param token 原Token
     * @return 新Token
     */
    public static String refreshToken(String token) {
        return refreshToken(token, DEFAULT_EXPIRATION);
    }
  
    /**
     * 刷新Token（更新过期时间）
     * @param token 原Token
     * @param expiration 新的有效期（毫秒）
     * @return 新Token
     */
    public static String refreshToken(String token, long expiration) {
        Claims claims = parseToken(token);
        claims.setIssuedAt(new Date());
        claims.setExpiration(new Date(System.currentTimeMillis() + expiration));
      
        return Jwts.builder()
                .setClaims(claims)
                .signWith(SECRET_KEY, SignatureAlgorithm.HS256)
                .compact();
    }
}
```

使用示例：

```java
import java.util.HashMap;
import java.util.Map;

/**
 * JWT工具类使用示例
 */
public class JwtExample {
    public static void main(String[] args) {
        // 示例1：生成简单Token
        String token = JwtUtil.generateToken("user123");
        System.out.println("生成的Token: " + token);
      
        // 示例2：生成带有多声明的Token
        Map<String, Object> claims = new HashMap<>();
        claims.put("sub", "user123");
        claims.put("username", "john.doe");
        claims.put("role", "admin");
      
        String complexToken = JwtUtil.generateToken(claims);
        System.out.println("生成的复杂Token: " + complexToken);
      
        // 示例3：解析Token
        try {
            String subject = JwtUtil.getSubject(token);
            System.out.println("Token中的主题: " + subject);
          
            String username = (String) JwtUtil.getClaim(complexToken, "username");
            System.out.println("Token中的用户名: " + username);
        } catch (Exception e) {
            System.out.println("Token解析失败: " + e.getMessage());
        }
      
        // 示例4：验证Token
        boolean isValid = JwtUtil.validateToken(token);
        System.out.println("Token是否有效: " + isValid);
      
        // 示例5：刷新Token
        String refreshedToken = JwtUtil.refreshToken(token);
        System.out.println("刷新后的Token: " + refreshedToken);
    }
}
```
